# 分布式锁

[TOC]



## 1 请求的幂等处理

#### 幂等的概念：

幂等一词源自数学概念，在程序中如果相同条件下多次请求对资源的影响表现一致则称请求为幂等请求，对应的接口为幂等接口。

#### 幂等的处理:

##### 1 使用数据库主键、唯一索引，防止重复数据插入；

特点：实现简单，但通用性差，也无法解决并发请求对应用服务的消耗；

##### 2 使用分布式锁（可通过redis实现）

分布式锁一般适用于需要长时间处理的任务，在任务处理期间防止重复请求，如数据导出、复杂计算等，由于这些操作本身就要求串行处理，所以加锁对性能地影响有限（锁粒度为请求条件）

##### 3 缓存请求URI并设定超时时长

URI做为请求Token再加上过期时间，比如 `PUT /user/001` 幂等有效时间30秒，则在30秒内同一个URI请求都视为重复直接过滤，这种做法可简化请求方操作但仅限于REST请求且符合REST规范。

##### 4 将请求放到MQ然后再进行处理

主流的 MQ 实现在 `autocommit=true` 时天然实现了幂等；但考虑业务处理可能出错的情况我们一般会将 autocommit 设置成 false ，在业务处理成功后再提交，这时就需要使用上述幂等方案了：在接收到消息时写入请求Token以实现去重判断（Token可为Topic+Offset）提交后删除Token，整体上可以做到对业务透明。



#### dos攻击预防：



## 2 分布式锁

#### 实现方法：

从理解的难易程度角度（从低到高）：数据库 > 缓存 > Zookeeper

从实现的复杂性角度（从低到高）：Zookeeper >= 缓存 > 数据库

从性能角度（从高到低）：缓存 > Zookeeper >= 数据库

从可靠性角度（从高到低）：Zookeeper > 缓存 > 数据库



##### 1 关系型数据库

 由关系型数据库的某些特性来实现，比如使用主键唯一性约束及数据一致来确保同一时间只有一个请求能获得锁，这一方案实现简单，但对高并发场景或可重入时存在比较大的性能瓶颈。



##### 2 Redis

可使用Redis单线程、原子化操作（setnx）来实现，这一方案也很简单；

但因为没有原子化的值比较方法，无法原子化确认占用锁的是否是当前实例的当前线程导致比较难实现重入锁(可以通过原子操作脚本的方式实现值比较)；

另外Redis单节点有高可用问题，多节点引入 RedLock 也存在比较大的[争议](https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html)。当然在绝大多数情况下大家还是可以放心使用的

```
SETNX命令（SET if Not eXists）
语法：SETNX key value
功能：原子性操作，当且仅当 key 不存在，将 key 的值设为 value ，并返回1；若给定的 key 已经存在，则 SETNX 不做任何动作，并返回0。

Expire命令
语法：expire(key, expireTime)
功能：key设置过期时间

GETSET命令
语法：GETSET key value
功能：将给定 key 的值设为 value ，并返回 key 的旧值 (old value)，当 key 存在但不是字符串类型时，返回一个错误，当key不存在时，返回nil。

GET命令
语法：GET key
功能：返回 key 所关联的字符串值，如果 key 不存在那么返回特殊值 nil 。

DEL命令
语法：DEL key [KEY …]
功能：删除给定的一个或多个 key ,不存在的 key 会被忽略。

```



##### 3 Zookeeper

可使用Zookeeper的持久节点（PERSISTENT）、临时节点（EPHEMERAL）、时序节点（SEQUENTIAL ）的特性组合及 watcher 接口实现，这一方案可保证最为严格的数据一致性、在性能及高可用也有着比较好的表现，推荐对一致性高要求极高、并发量大的场景使用。


