# Java并发编程 - 多线程的安全

[TOC]

## 多线程的风险

#### 活跃性问题

- 死锁

  哲学家吃饭问题：5个哲学家吃饭，1人只给1支筷子；如果大家同时吃饭，谁也不借给别人筷子，大家都不能吃饭；

  可通过JConsole检测。

- 饥饿

  食堂排队买饭：买上的不走，那么后边就一直买不上。

  **情景**

  - 高优先级吞噬低优先级的时间片；（ setPriority() ）
  - 线程被永久堵塞在一个等待进入同步块的状态；
  - 等待的线程永远不被唤醒

​       

- 活锁

  两个人从河两边过独木桥，他们已相逢就同时后退，然后又在另一个独木桥相逢，然后又同时后退。

#### 性能：

多线程并不一定比单线程快。

单核cpu上也可以运行多线程。因为cpu是分出多个小的时间片，来执行线程任务的，通过时间片的快速切换来达到并行的效果。cpu的核数越少，线程越多时，上下文的切换频率就越高，消耗就越高。



## 线程安全

在多线程环境，依然复合预期的，就是线程安全的，否则就不是线程安全的。



线程安全问题出现的条件：

- 多线程并行
- 共享一个资源
- 对资源进行了非原子性操作



解决线程安全问题的方法

- synchronized 同步方法/代码块

- 锁

- 原子类

  

synchronized 同步方法/代码块

- 内置锁：每个Java中的对象都是内置锁。
- 锁是互斥的