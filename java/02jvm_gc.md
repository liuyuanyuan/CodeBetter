#  垃圾收集GC与内存分配

[TOC]



垃圾收集 （Garbage Collection， 简称GC)，历史比Java更悠久。早在1960年MIT诞生的Lisp是第一门开始使用内存动态分配和垃圾收集技术的语言。

垃圾收集要完成三件事：

-  哪些内存需要回收（或者说哪些内存是垃圾）？

- 什么时候回收？

- 如何回收？

  

## 判定对象消亡的算法

### 引用计数算法（reference counting）

**原理**：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象是不可能再被引用的。

**特点**：概算占用了少量的内存空间来计数，但原理简单，判定效率高；但是该算法不够完善，有很多例外的情况需要考虑，比如对象之间的相互循环引用的问题。

### 可达性分析算法（Reachability Analysis）

当前主流的商用程序语言（java、c#以及上溯古老的Lisp）的内存管理都是通过可达性分析算法来判断对象是否存活。

**原理**：通过一系列成为”GC Root“的根对象作为起始节点集，从这些节点开始根据引用关系向下搜索，搜索过程所走过的路径成为”引用链（reference chain）“，如果某对象到GC Root间没有任何引用链相连，或者用图论的话说就是炒年糕GC Root到这个对象不可达，则证明这个对象是不可能再被使用的。

**在Java技术体系中，固定可以作为GCRoot的对象包括：**

- 在虚拟机栈中（栈帧中的本地变量表）中引用的对象，如各线程中被调用的方法堆栈中使用的参数、局部变量、临时变量等。
- 方法区中类静态属性引用的对象，如Java类的引用类型静态变量；
- 方法区中常量引用的对象，如字符串常量池（String table）里的引用；
- 本地方法栈中JNI引用的对象；
- JVM内部的引用，如基本数据类型对应的class对象， 一些常驻的异常对象如NullPointerException、OutOfMemoryError。
- 所有被同步锁持有（synchronized修饰的）对象；
- 反映JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等；



### 附注：Java中引用的概念

JDK1.2之后，Java对引用的概念进行了扩充，强度由强到弱，将引用分为：

- 强引用 Strongly Reference：是最传统的“引用”的定义。

  是指在程序代码中普遍存在的引用赋值，即类似`Object obj = new Obejct();` 这种引用关系。

  任何情况下，只要强引用关系还在，垃圾收集器就永远不会收集被引用的对象。

- 软引用Soft Reference：是JDK1.2之后新增的。

  用来描述还有用但非必须的对象；

-  弱引用Weak Reference：是JDK1.2之后新增的。

  用来描述还有用但非必须的对象；

- 虚引用 Phantom Reference：是JDK1.2之后新增的。

​       最弱的一种引用关系。



## 垃圾收集算法

根据判定对象消亡的算法，垃圾收集算法分为两大类：

- 引用计数式垃圾收集 Reference counting GC（也称作直接垃圾收集）
- 追踪式垃圾收集 Tracing GC（也称作间接垃圾收集）

引用计数式垃圾收集算法在主流JVM中均为涉及，以下所有垃圾收集算法均属于追踪式垃圾收集。



### 分代收集理论

##### 部分收集Partial GC：

##### 整堆收集Full GC：



### 标记-清除算法：



### 标记-复制算法：



### 标记-整理算法：



## HotSpot 算法实现细节







## 流行的垃圾收集器

### Serial收集器：

是最基础、历史最悠久的垃圾收集器；在JDK1.3之前是Hotspot VM新生代收集器的唯一选择。

是一个单线程工作的收集器；它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。

迄今为止，它依然是Hotspot vm运行在客户端模式下的默认新生代收集器。它的简单高效（与其他收集器的单线程相比）优于其他收集器。

运行示意图：



### ParNew收集器

实际上是Serial收集器的多线程并行版本。



>在谈论垃圾收集器的上下文中，并行和并发的理解如下：
>
>- 并行：同一时间有多条垃圾收集器的线程在协同工作，通常默认此时用户线程是处于等待状态。
>
>- 并发：同一时间垃圾收集器线程和用户线程都在运行。



运行示意图：





