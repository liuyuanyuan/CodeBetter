# 概念基础篇

[TOC]

## 1 面向对象编程的三大特征：封装、继承、多态

## 封装(Encapsulation)：

在面向对象程式设计方法中，封装是一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法（private 或者 final修饰的任何外部类均不可修改）。

封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。

把客观的事物封装成抽象的类，用封装来实现高内聚，低耦合。

   - 内聚：是指一个模块内部各个部分之间的关联程度;
   - 耦合：指各个模块之间的关联程度;



## 继承(extends)：

**继承是Java面向对象编程技术的一块基石**，因为它允许创建分等级层次的类。

继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

**类的继承格式：**

在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：

```
class 父类 { }  class 子类 extends 父类 { }
```

### Java中，仅支持单继承（不支持多继承），但支持多重继承：

![image-20200312105312257](images/java_extends.png)



## 多态(polymorphism)：

多态是同一个行为，具有多个不同表现形式或形态的能力。

多态就是同一个接口，使用不同的实例而执行不同操作。

**多态的实现方式：**

- 重写：将父类方法的行为重写；
- 接口：被具体类继承，对接口中的抽象方法实现不同行为；
- 抽象类和抽象方法：被具体类实现，从而对抽象方法实现不同的行为；

**多态存在的三个必要条件**：

- 继承
- 重写
- 父类引用指向子类对象

```java
//继承
class Cat extends Animal {  
    //重写
    @Override
    public void eat() {  
        System.out.println("吃鱼");  
    }  
    @Override
    public void work() {  
        System.out.println("抓老鼠");  
    }  
}

public class Test {
    public static void main(String[] args) {            
      //父类指向子类
      Animal a = new Cat();  // 向上转型  
      show(a);
    }  
    public static void show(Animal a)  {
        a.eat(); //具体动物类重写了该方法
        a.work(); 
    } 
」
```



## 抽象类与抽象方法(abstract)

在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的；**如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。**

**抽象类不能实例化对象之外，除此之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。**

由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。

在 Java 中，抽象类表示的是一种继承关系，**一个类只能继承一个抽象类，而一个类却可以实现多个接口**。

### 抽象方法

如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。

Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。

**声明抽象方法会造成以下两个结果**：

- 如果一个类包含抽象方法，那么该类必须是抽象类。
- 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。



## 接口(interface）：接口不是类，不具有类的功能

接口（Interface），在JAVA编程语言中是一个抽象类型**，是抽象方法的集合**，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。

接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。

除非实现接口的类是抽象类，否则该类要实现接口中的所有方法。

接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。

```
//接口的声明语法格式如下：
[可见度] interface 接口名称 [extends 其他的接口名] {        
		// 声明变量        
		// 抽象(abstract)方法 
}

//接口的实现语法各式如下：
...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...
```

**接口与类相似点：**

- 一个接口可以有多个方法。
- 接口文件保存在 .java 结尾的文件中，文件名使用接口名。
- 接口的字节码文件保存在 .class 结尾的文件中。
- 接口相应的字节码文件必须在与包名称相匹配的目录结构中。

**接口与类的区别：**

- 接口不能用于实例化对象。
- 接口没有构造方法。
- 接口中所有的方法必须是抽象方法。
- 接口不能包含成员变量，除了 static 和 final 变量。
- 接口不是被类继承了，而是要被类实现。
- 接口支持多继承。

### 标记接口

定义：标记接口是没有任何方法和属性的接口；它仅仅表明它的类属于一个特定的类型，供其他代码来测试允许做一些事情。

作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。例如：java.uitl 包中的 RandomAccess 接口，主要用于标记集合是支持快速随机访问的。

标记接口主要用于以下两种目的：

- 建立一个公共的父接口：

  正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。

- 向一个类添加数据类型：

  这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。

### 抽象类和接口的区别

- 抽象类中的方法可以有方法体，就是能实现方法的具体功能；但是接口中的方法只能是抽象方法。

- 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 **public static final** 类型的。

- 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。

  > **注**：JDK 1.8 以后，接口里可以有静态方法和方法体了。

- 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

  

## Java包(package)

为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。

**包的作用**

- 1 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。
- 2 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。
- 3 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。

Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。

**包语句的语法格式为：**

```
package pkg1[．pkg2[．pkg3…]];
```



## 方法的重载(override)、重写(overload) 

### 方法(非构造函数)的重写(override)

重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。**即外壳不变，核心重写。**

重写的好处在于子类可以根据需要，定义特定于自己的行为。 即子类能够根据需要实现父类的方法。

#### 方法的重写规则

- 参数列表必须完全与被重写方法的相同。
- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
- 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
- 父类的成员方法只能被它的子类重写。
- 声明为 final 的方法不能被重写。
- 声明为 static 的方法不能被重写，但是能够被再次声明。
- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写方法不能抛出新的检查异常，或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常
- 构造方法不能被重写。
- 如果不能继承一个方法，则不能重写这个方法。



### 方法(常为构造函数)的重载(overload) 

重载(overloading) 是在一个类里面，方法名字相同，而参数不同，返回类型可以相同也可以不同。

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

最常用的地方就是构造器的重载。

#### 方法/构造函数的重载规则:

- 被重载的方法必须改变参数列表(参数个数或类型不一样)；

- 被重载的方法可以改变返回类型；

- 被重载的方法可以改变访问修饰符；

- 被重载的方法可以声明新的或更广的检查异常；

- 方法能够在同一个类中或者在一个子类中被重载。

- 无法以返回值类型作为重载函数的区分标准。

  

## final 关键字

final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。

- 声明类：

  ```
  final class 类名 {//类体}
  ```

- 声明方法：

  ```
  修饰符(public/private/default/protected) final 返回值类型 方法名(){//方法体}
  ```



## super 与 this 关键字

- super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。

  使用：当需要在子类中调用父类的被重写方法时，要使用 super 关键字，如：

  ```java
  class Dog extends Animal{
     public void move(){
        super.move(); // 应用super类的方法
        System.out.println("狗可以跑和走");
     }
  }
  ```


- this关键字：指向自己的引用。

  使用：常用于（构造）方法中，区别类的引用(this.x)与方法参数列表中的引用(x)。

  ```java
  public class Person {
   	private String name;
  	public Person(String name){
  		this.name = name;
    }
  }
  ```

  

